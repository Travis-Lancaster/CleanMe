// This file is auto-generated by zod-dbs. Do not edit this file directly.

import { z } from "zod";

/**
 * Base read schema for the "dbo.SyncChangeLog" table.
 * Validates raw rows read from the database (no casing transforms applied yet).
 */
export const SyncChangeLogTableBaseSchema = z.object({
	/**
	 * dataType: uniqueidentifier
	 */
	ChangeId: z.any(),
	/**
	 * dataType: nvarchar
	 */
	TableName: z.string(),
	/**
	 * dataType: uniqueidentifier
	 */
	EntityId: z.any(),
	/**
	 * dataType: nvarchar
	 */
	Operation: z.string(),
	/**
	 * dataType: nvarchar
	 */
	ChangeData: z.string().nullable().transform(value => value ?? undefined).optional(),
	/**
	 * dataType: nvarchar
	 */
	PreviousData: z.string().nullable().transform(value => value ?? undefined).optional(),
	/**
	 * dataType: bigint
	 */
	Revision: z.number(),
	/**
	 * dataType: datetime2
	 */
	Timestamp: z.any(),
	/**
	 * dataType: uniqueidentifier
	 */
	UserId: z.any().nullable().transform(value => value ?? undefined).optional(),
	/**
	 * dataType: uniqueidentifier
	 */
	SyncBatch: z.any().nullable().transform(value => value ?? undefined).optional(),
	/**
	 * dataType: nvarchar
	 */
	ClientId: z.string().nullable().transform(value => value ?? undefined).optional(),
	/**
	 * dataType: nvarchar
	 */
	ConflictResolution: z.string().nullable().transform(value => value ?? undefined).optional(),
});

/**
 * The base record type for the "dbo.SyncChangeLog" table.
 * This type represents the raw database record without case transforms.
 */
export type SyncChangeLogBaseRecord = z.output<typeof SyncChangeLogTableBaseSchema>;

/**
 * Read transform for the "dbo.SyncChangeLog" table.
 * Maps database fields to app case properties.
 */
export function transformSyncChangeLogBaseRecord(data: SyncChangeLogBaseRecord): {
	changeId: SyncChangeLogBaseRecord["ChangeId"]
	tableName: SyncChangeLogBaseRecord["TableName"]
	entityId: SyncChangeLogBaseRecord["EntityId"]
	operation: SyncChangeLogBaseRecord["Operation"]
	changeData?: SyncChangeLogBaseRecord["ChangeData"]
	previousData?: SyncChangeLogBaseRecord["PreviousData"]
	revision: SyncChangeLogBaseRecord["Revision"]
	timestamp: SyncChangeLogBaseRecord["Timestamp"]
	userId?: SyncChangeLogBaseRecord["UserId"]
	syncBatch?: SyncChangeLogBaseRecord["SyncBatch"]
	clientId?: SyncChangeLogBaseRecord["ClientId"]
	conflictResolution?: SyncChangeLogBaseRecord["ConflictResolution"]
} {
	return {
		changeId: data.ChangeId,
		tableName: data.TableName,
		entityId: data.EntityId,
		operation: data.Operation,
		changeData: data.ChangeData,
		previousData: data.PreviousData,
		revision: data.Revision,
		timestamp: data.Timestamp,
		userId: data.UserId,
		syncBatch: data.SyncBatch,
		clientId: data.ClientId,
		conflictResolution: data.ConflictResolution,
	};
}

/**
 * Read schema for the "dbo.SyncChangeLog" table (after casing transform).
 */
export const SyncChangeLogTableSchema = SyncChangeLogTableBaseSchema.transform(transformSyncChangeLogBaseRecord);

/**
 * Base insert/write schema for the "dbo.SyncChangeLog" table (no casing transforms).
 */
export const SyncChangeLogTableInsertBaseSchema = z.object({
	/**
	 * dataType: uniqueidentifier
	 * defaultValue: (newid())
	 */
	changeId: z.any().optional(),
	/**
	 * dataType: nvarchar
	 */
	tableName: z.string().max(100),
	/**
	 * dataType: uniqueidentifier
	 */
	entityId: z.any(),
	/**
	 * dataType: nvarchar
	 */
	operation: z.string().max(10),
	/**
	 * dataType: nvarchar
	 */
	changeData: z.string().max(-1).nullable().optional(),
	/**
	 * dataType: nvarchar
	 */
	previousData: z.string().max(-1).nullable().optional(),
	/**
	 * dataType: bigint
	 */
	revision: z.number().int(),
	/**
	 * dataType: datetime2
	 * defaultValue: (getutcdate())
	 */
	timestamp: z.any().optional(),
	/**
	 * dataType: uniqueidentifier
	 */
	userId: z.any().nullable().optional(),
	/**
	 * dataType: uniqueidentifier
	 */
	syncBatch: z.any().nullable().optional(),
	/**
	 * dataType: nvarchar
	 */
	clientId: z.string().max(100).nullable().optional(),
	/**
	 * dataType: nvarchar
	 */
	conflictResolution: z.string().max(50).nullable().optional(),
});

/**
 * The base record type for the "dbo.SyncChangeLog" table.
 * This type represents an insertable database record before casing transformations are applied.
 */
export type SyncChangeLogInsertBaseRecord = z.output<typeof SyncChangeLogTableInsertBaseSchema>;

/**
 * The base record type for the "dbo.SyncChangeLog" table.
 * This type represents an updatable database record before casing transformations are applied.
 */
export type SyncChangeLogUpdateBaseRecord = Partial<SyncChangeLogInsertBaseRecord>;

/**
 * Insert transform for the "dbo.SyncChangeLog" table.
 * Maps app cased properties to database fields.
 */
export function transformSyncChangeLogInsertBaseRecord(data: SyncChangeLogInsertBaseRecord): {
	ChangeId?: SyncChangeLogInsertBaseRecord["changeId"]
	TableName: SyncChangeLogInsertBaseRecord["tableName"]
	EntityId: SyncChangeLogInsertBaseRecord["entityId"]
	Operation: SyncChangeLogInsertBaseRecord["operation"]
	ChangeData?: SyncChangeLogInsertBaseRecord["changeData"]
	PreviousData?: SyncChangeLogInsertBaseRecord["previousData"]
	Revision: SyncChangeLogInsertBaseRecord["revision"]
	Timestamp?: SyncChangeLogInsertBaseRecord["timestamp"]
	UserId?: SyncChangeLogInsertBaseRecord["userId"]
	SyncBatch?: SyncChangeLogInsertBaseRecord["syncBatch"]
	ClientId?: SyncChangeLogInsertBaseRecord["clientId"]
	ConflictResolution?: SyncChangeLogInsertBaseRecord["conflictResolution"]
} {
	return {
		ChangeId: data.changeId,
		TableName: data.tableName,
		EntityId: data.entityId,
		Operation: data.operation,
		ChangeData: data.changeData,
		PreviousData: data.previousData,
		Revision: data.revision,
		Timestamp: data.timestamp,
		UserId: data.userId,
		SyncBatch: data.syncBatch,
		ClientId: data.clientId,
		ConflictResolution: data.conflictResolution,
	};
}

/**
 * Update transform for the "dbo.SyncChangeLog" table.
 * Maps app cased properties to database fields.
 */
export function transformSyncChangeLogUpdateBaseRecord(data: SyncChangeLogUpdateBaseRecord): {
	ChangeId?: SyncChangeLogUpdateBaseRecord["changeId"]
	TableName: SyncChangeLogUpdateBaseRecord["tableName"]
	EntityId: SyncChangeLogUpdateBaseRecord["entityId"]
	Operation: SyncChangeLogUpdateBaseRecord["operation"]
	ChangeData?: SyncChangeLogUpdateBaseRecord["changeData"]
	PreviousData?: SyncChangeLogUpdateBaseRecord["previousData"]
	Revision: SyncChangeLogUpdateBaseRecord["revision"]
	Timestamp?: SyncChangeLogUpdateBaseRecord["timestamp"]
	UserId?: SyncChangeLogUpdateBaseRecord["userId"]
	SyncBatch?: SyncChangeLogUpdateBaseRecord["syncBatch"]
	ClientId?: SyncChangeLogUpdateBaseRecord["clientId"]
	ConflictResolution?: SyncChangeLogUpdateBaseRecord["conflictResolution"]
} {
	return {
		ChangeId: data.changeId,
		TableName: data.tableName,
		EntityId: data.entityId,
		Operation: data.operation,
		ChangeData: data.changeData,
		PreviousData: data.previousData,
		Revision: data.revision,
		Timestamp: data.timestamp,
		UserId: data.userId,
		SyncBatch: data.syncBatch,
		ClientId: data.clientId,
		ConflictResolution: data.conflictResolution,
	};
}

/**
 * Insert schema for the "dbo.SyncChangeLog" table (after casing transform).
 */
export const SyncChangeLogTableInsertSchema = SyncChangeLogTableInsertBaseSchema.transform(transformSyncChangeLogInsertBaseRecord);

/**
 * Update schema for the "dbo.SyncChangeLog" table (after casing transform).
 */
export const SyncChangeLogTableUpdateSchema = SyncChangeLogTableInsertBaseSchema.partial().transform(transformSyncChangeLogUpdateBaseRecord);

type TableInsertRecord = z.input<typeof SyncChangeLogTableInsertSchema>;
type TableReadRecord = z.output<typeof SyncChangeLogTableSchema>;

/**
 * Read record (casing transformed) for the "dbo.SyncChangeLog" table.
 */
export interface SyncChangeLogRecord {
	changeId: TableReadRecord["changeId"]
	tableName: TableReadRecord["tableName"]
	entityId: TableReadRecord["entityId"]
	operation: TableReadRecord["operation"]
	changeData?: TableReadRecord["changeData"]
	previousData?: TableReadRecord["previousData"]
	revision: TableReadRecord["revision"]
	timestamp: TableReadRecord["timestamp"]
	userId?: TableReadRecord["userId"]
	syncBatch?: TableReadRecord["syncBatch"]
	clientId?: TableReadRecord["clientId"]
	conflictResolution?: TableReadRecord["conflictResolution"]
}

/**
 * Insert record (casing transformed) for the "dbo.SyncChangeLog" table.
 */
export interface SyncChangeLogInsertRecord {
	/**
	 * @default: (newid())
	 */
	changeId?: TableInsertRecord["changeId"]
	/**
	 * @maxLen: 100
	 */
	tableName: TableInsertRecord["tableName"]
	entityId: TableInsertRecord["entityId"]
	/**
	 * @maxLen: 10
	 */
	operation: TableInsertRecord["operation"]
	/**
	 * @maxLen: -1
	 */
	changeData?: TableInsertRecord["changeData"]
	/**
	 * @maxLen: -1
	 */
	previousData?: TableInsertRecord["previousData"]
	revision: TableInsertRecord["revision"]
	/**
	 * @default: (getutcdate())
	 */
	timestamp?: TableInsertRecord["timestamp"]
	userId?: TableInsertRecord["userId"]
	syncBatch?: TableInsertRecord["syncBatch"]
	/**
	 * @maxLen: 100
	 */
	clientId?: TableInsertRecord["clientId"]
	/**
	 * @maxLen: 50
	 */
	conflictResolution?: TableInsertRecord["conflictResolution"]
}

/**
 * Updatable record (casing transformed) for the "dbo.SyncChangeLog" table.
 */
export type SyncChangeLogUpdateRecord = Partial<SyncChangeLogInsertRecord>;
